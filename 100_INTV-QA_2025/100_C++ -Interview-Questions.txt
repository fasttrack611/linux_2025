
===================================================================================================================================
What is C++ and what are its main features?

C++ is a general-purpose, object-oriented programming language that was developed by Bjarne Stroustrup in the 
early 1980s as an extension of the C programming language. It supports a wide range of programming paradigms, 
including procedural, object-oriented, and generic programming.

Some of the main features of C++ include:

Strong typing: C++ is a strongly-typed language, which means that variables must be declared with their data types before they can be used.

Object-oriented programming: C++ supports object-oriented programming concepts such as encapsulation, inheritance, and polymorphism.

Memory management: C++ allows for both automatic and manual memory management. 
It provides features like pointers, references, and the new and delete operators to manage memory.

Templates: C++ allows for generic programming through the use of templates. 
This allows for the creation of generic data structures and algorithms that can work with any data type.

Performance: C++ is known for its high performance and efficiency.
 It allows for low-level programming and direct access to system resources.

Standard Library: C++ provides a large standard library that includes 
	a wide range of functions and data structures that can be used in a variety of applications.

Overall, C++ is a powerful programming language that is widely used in a variety of industries,
 including game development, operating system development, and finance.

==========================================================================================================================================================
What is the difference between C and C++?

C and C++ are both programming languages that share some similarities, but they also have some significant differences.

Object-oriented programming: One of the most significant differences between C and C++ is that C++ supports object-oriented programming (OOP), 
				while C does not. OOP allows for code reusability, abstraction, and encapsulation.

Function overloading: C++ allows for function overloading, which means that you can define multiple functions with the same name but different parameters.
 In C, function overloading is not supported.

Operator overloading: C++ allows for operator overloading, 
which means that you can define how operators such as +, -, *, and / work with user-defined types. In C, operator overloading is not supported.

Standard Library: C++ provides a larger Standard Library than C.
The Standard Library includes a wide range of functions and data structures that can be used in a variety of applications.

Memory Management: C++ provides support for both automatic and manual memory management through the use of the new and delete operators.
C does not provide any support for automatic memory management.

Compatibility: C++ is backward compatible with C, which means that C++ can compile C code, but the opposite is not true.

Overall, C++ is a more powerful and flexible language than C, with support for OOP and other advanced features. 
However, C still remains a popular language for certain applications,
such as operating system development, due to its simplicity and low-level access to hardware.

==========================================================================================================================================================


What is object-oriented programming (OOP)?

Object-oriented programming (OOP) is a programming paradigm that is based on the concept of "objects". 
It is a programming approach that uses objects to represent real-world entities and provides a way to organize and structure code.

In OOP, objects are instances of classes, which define the properties and behaviors of the object.
Each object has its own state and behavior, and can interact with other objects through methods, which are functions that belong to the class.

The main features of OOP include:
=========================================
Encapsulation: The concept of encapsulation refers to the bundling of data and methods into a single entity called a class. 
		This allows for the protection and control of access to the data, and provides a way to hide the implementation details from the user.

Inheritance: Inheritance allows for the creation of new classes that are derived from existing classes. 
		The derived class inherits the properties and behaviors of the base class, and can add or modify its own properties and behaviors.

Polymorphism: Polymorphism allows for the same method to be used to perform different tasks depending on the context. This allows for code reusability and flexibility.

Overall, OOP provides a way to create modular, reusable, and maintainable code, 
which can be easily extended and adapted to new requirements. 
It is widely used in a variety of industries, including software development, game development, and finance.

======================================================================================================================================
What are the pillars of OOP?

The pillars of OOP are the fundamental concepts that underlie object-oriented programming. These pillars are:

Encapsulation: Encapsulation is the concept of bundling data and methods into a single unit called a class. 
		It allows for the protection of data from outside access and modification, 
		and provides a way to control the interaction between objects.

Inheritance: Inheritance is the concept of creating a new class from an existing class, with the new
	 class inheriting the properties and behaviors of the existing class. 
	  It allows for code reuse and reduces code duplication, and provides a way to model relationships between objects.

Polymorphism: Polymorphism is the concept of using a single interface to represent multiple types.
	     It allows for the same method to be used to perform different tasks depending on the context,
		and provides a way to extend and adapt code to new requirements.

Overall, these pillars provide a way to organize and structure code in a modular,
 reusable, and maintainable way, and are essential concepts for any object-oriented programming language.

======================================================================================================================================

What is inheritance in C++?

Inheritance is a concept in C++ that allows a new class to be based on an existing class, 
inheriting its properties and behaviors. 
The existing class is called the base class or superclass, 
while the new class is called the derived class or subclass.

The derived class inherits the members of the base class,
 including its data members and member functions. 
It can also add its own data members and member functions. 
This allows for code reuse and reduces code duplication, 
as the derived class can reuse the functionality of the base class without having to rewrite it.

In C++, inheritance is declared using the class keyword, 
followed by the name of the derived class, 
and the : symbol, followed by the access specifier 
(public, protected, or private) and the name of the base class.

Here is an example of inheritance in C++:
==================================================
class Animal {
public:
    void eat() {
        std::cout << "I am eating" << std::endl;
    }
};

class Cat : public Animal {
public:
    void meow() {
        std::cout << "Meow" << std::endl;
    }
};

int main() {
    Cat cat;
    cat.eat(); // Output: I am eating
    cat.meow(); // Output: Meow
    return 0;
}
=================================================================================================================================================


What is polymorphism in C++?

Polymorphism is a concept in C++ that allows a single interface to be used to represent multiple types or objects.
It allows different classes to have the same name for their member functions, but behave differently depending on the context. 

There are two types of polymorphism in C++: 
--> compile-time polymorphism (also known as static polymorphism) 
--> run-time polymorphism (also known as dynamic polymorphism).

Compile-time polymorphism is achieved through function overloading and operator overloading. 
Function overloading allows multiple functions with the same name to be defined in the same scope, but with different parameter lists. 
Operator overloading allows operators such as +, -, *, and / to be defined to work with user-defined types.

Run-time polymorphism is achieved through virtual functions and the use of pointers or references.
Virtual functions are functions that are declared in the base class and overridden in the derived class.
When a virtual function is called using a pointer or reference to the base class, 
the function that is called depends on the actual type of the object being pointed to or referenced.

Here is an example of run-time polymorphism in C++ using virtual functions:

class Animal {
public:
    virtual void makeSound() {
        std::cout << "The animal makes a sound" << std::endl;
    }
};

class Dog : public Animal {
public:
    void makeSound() override {
        std::cout << "The dog barks" << std::endl;
    }
};

class Cat : public Animal {
public:
    void makeSound() override {
        std::cout << "The cat meows" << std::endl;
    }
};

int main() {
    Animal* animal;
    Dog dog;
    Cat cat;

    animal = &dog;
    animal->makeSound(); // Output: The dog barks

    animal = &cat;
    animal->makeSound(); // Output: The cat meows

    return 0;
}

======================================================================================

What is encapsulation in C++?

Encapsulation is a concept in C++ that refers to the bundling of data and functions that operate on that data into a single unit, called a class. 
Encapsulation allows the data to be hidden from the outside world and can only be accessed through 
the public functions of the class. This provides a level of security and prevents external code from accessing or modifying the data directly.

In C++, access specifiers (public, protected, and private) are used to specify the visibility of the members of a class. 
The public members can be accessed from anywhere, while the private members can only be accessed from within the same class.
The protected members can be accessed from within the same class and its derived classes.


class BankAccount {
private:
    double balance;

public:
    BankAccount(double initialBalance) {
        balance = initialBalance;
    }

    void deposit(double amount) {
        balance += amount;
    }

    void withdraw(double amount) {
        if (balance >= amount) {
            balance -= amount;
        } else {
            std::cout << "Insufficient funds" << std::endl;
        }
    }

    double getBalance() const {
        return balance;
    }
};

int main() {
    BankAccount account(1000);
    account.deposit(500);
    account.withdraw(2000);
    std::cout << "Balance: " << account.getBalance() << std::endl;
    return 0;
}


========================================================================================
What is abstraction in C++?

Abstraction is a concept in C++ that refers to the ability to focus on essential features of an object while ignoring irrelevant details.
 It is achieved through the use of abstract classes and pure virtual functions.

An abstract class is a class that cannot be instantiated and is intended to be used as a base class for other classes. 
It defines an interface for derived classes, but does not provide an implementation for all the member functions. 
A pure virtual function is a virtual function that is declared in the base class but has no implementation. 
It is intended to be overridden by derived classes.

Here is an example of abstraction in C++:

class Shape {
public:
    virtual double getArea() const = 0;
};

class Rectangle : public Shape {
private:
    double width;
    double height;

public:
    Rectangle(double w, double h) : width(w), height(h) {}

    double getArea() const override {
        return width * height;
    }
};

class Circle : public Shape {
private:
    double radius;

public:
    Circle(double r) : radius(r) {}

    double getArea() const override {
        return 3.14 * radius * radius;
    }
};

int main() {
    Shape* shapes[2];
    shapes[0] = new Rectangle(5, 10);
    shapes[1] = new Circle(5);

    for (int i = 0; i < 2; i++) {
        std::cout << "Area: " << shapes[i]->getArea() << std::endl;
        delete shapes[i];
    }

    return 0;
}
============================================================================================================================

What is a class in C++?

A class in C++ is a user-defined data type that encapsulates data and functions that operate on that data. 
It is a blueprint for creating objects, which are instances of the class. 
A class provides a way to define a new type with its own characteristics, behavior, and operations.

A class is defined using the class keyword, followed by the name of the class 
and a block of code that defines its data members and member functions. 
The data members represent the state of the object, while the member functions represent the behavior of the object.
==========================================================================================================================

What is an object in C++?

In C++, an object is an instance of a class that encapsulates data and behavior.
It is created using the new operator and destroyed using the delete operator.
An object is a concrete, tangible entity that can be manipulated and interacted with in a program.

Each object of a class has its own set of data members, which represent the state of the object, 
 and its own set of member functions, which define the behavior of the object.
 When an object is created, memory is allocated to store its data members, 
 and the constructor of the class is called to initialize them.

class Person {

private:
    std::string name;
    int age;

public:
    Person(const std::string& n, int a) : name(n), age(a) {}

    void setName(const std::string& n) {
        name = n;
    }

    void setAge(int a) {
        age = a;
    }

    std::string getName() const {
        return name;
    }

    int getAge() const {
        return age;
    }
};

int main() {
    Person* p = new Person("Alice", 30);
    std::cout << "Name: " << p->getName() << ", Age: " << p->getAge() << std::endl;
    p->setName("Bob");
    p->setAge(40);
    std::cout << "Name: " << p->getName() << ", Age: " << p->getAge() << std::endl;
    delete p;
    return 0;
}



===============================================================================================
What is a constructor in C++?

A constructor in C++ is a special member function of a class that is used to 
initialize the object's data members when the object is created. It has the same name as the class and no return type.

When an object is created, memory is allocated to store its data members, and the constructor is called to initialize them.
The constructor can be used to set default values for the data members, to allocate memory dynamically,
or to perform any other initialization that is required.

There are two types of constructors in C++:

Default constructor: It is a constructor that takes no arguments. 
If a class does not have any user-defined constructors, 
a default constructor is provided by the compiler.

Parameterized constructor: It is a constructor that takes one or more arguments. 
It can be used to initialize the data members of the object with the values provided as arguments.

Here is an example of a constructor in C++:

class Person {
private:
    std::string name;
    int age;

public:
    Person(const std::string& n, int a) : name(n), age(a) {}
};

int main() {
    Person p("Alice", 30);
    return 0;
}

================================================================================================================================================================

What is a destructor in C++?

A destructor in C++ is a special member function of a class that is used to clean up
 the resources held by an object when it is destroyed. It has the same name as the class preceded by a tilde (~) and no arguments.

When an object is destroyed, the destructor is called automatically to release any resources that the object holds, 
such as dynamically allocated memory or open files. The destructor can also be used to perform any other cleanup that is required.

class Person {

private:
    std::string name;
    int age;

public:
    Person(const std::string& n, int a) : name(n), age(a) {}

    ~Person() {
        std::cout << "Destructor called for " << name << std::endl;
    }
};

int main() {
    Person p("Alice", 30);
    return 0;
}

================================================================================================================================================================

What is a virtual function in C++?

A virtual function in C++ is a member function of a class that can be overridden in a derived class. 
It is declared using the virtual keyword in the base class, 
and can be implemented in the base class or in any of its derived classes.

When a virtual function is called on a pointer or reference to an object, 
the function that is called is determined at runtime based on the actual type of the object,
 not the type of the pointer or reference. This is known as dynamic dispatch or late binding.

Here is an example of a virtual function in C++:

class Animal {
public:
    virtual void makeSound() {
        std::cout << "The animal makes a sound.\n";
    }
};

class Dog : public Animal {
public:
    void makeSound() override {
        std::cout << "The dog barks.\n";
    }
};

int main() {
    Animal* animalPtr = new Dog();
    animalPtr->makeSound(); // outputs "The dog barks."
    delete animalPtr;
    return 0;
}

====================================================================================================

What is a friend function in C++?

A Friend function in C++ is a function that is not a member of a class, 
but has access to the private and protected members of the class.

To declare a function as a friend of a class, the friend keyword is used in the class definition. 
A friend function can be either a standalone function or a member function of another class.

class MyClass {
private:
    int x;
public:
    MyClass(int a) : x(a) {}
    friend void printX(MyClass obj);
};

void printX(MyClass obj) {
    std::cout << "The value of x is: " << obj.x << std::endl;
}

int main() {
    MyClass obj(42);
    printX(obj);
    return 0;
}

====================================================================================================

What is the difference between a class and a struct in C++?
In C++, a class and a struct are very similar, with the main difference being the default access level for their members.

In a class, by default, all the members are private and can only be accessed by member functions or friend functions.
On the other hand, in a struct, by default, all the members are public and can be accessed directly.

====================================================================================================


What is a namespace in C++?

A namespace in C++ is a mechanism for organizing code elements 
(such as variables, functions, and classes) into logical groups to prevent naming conflicts.

A namespace definition begins with the namespace keyword followed by the 
name of the namespace and a pair of curly braces that enclose the code
elements that belong to the namespace. Code elements can be defined inside or outside the namespace definition.

Here is an example of how to define and use a namespace in C++:

#include <iostream>

namespace myNamespace {
    int x = 42;
    void printX() {
        std::cout << "The value of x is: " << x << std::endl;
    }
}

int main() {
    myNamespace::printX(); // Access the printX() function using the namespace qualifier
    return 0;
}

====================================================================================================
What is a template in C++?

A template in C++ is a mechanism for creating generic code that can work with different data types.
Templates allow you to define a single function or class that can be used with multiple data types, 
without having to rewrite the code for each type.

Templates are defined using the template keyword followed by the template parameter list enclosed in angle brackets. 
The template parameter list can include one or more template parameters, 
which can be data types or non-type parameters such as integers or booleans. 
The template parameter list is used to declare one or more template parameters that can be used in the template function or class.

#include <iostream>

template <typename T>
T max(T a, T b) {
    return a > b ? a : b;
}

int main() {
    int x = 5, y = 10;
    std::cout << "The maximum of " << x << " and " << y << " is " << max(x, y) << std::endl;

    double d1 = 3.14, d2 = 2.71;
    std::cout << "The maximum of " << d1 << " and " << d2 << " is " << max(d1, d2) << std::endl;

    return 0;
}


====================================================================================================

What is a function template in C++?

A function template in C++ is a generic function that can work with different data types. 
Function templates allow you to define a single function that can be used with multiple data types,
 without having to rewrite the code for each type.

A function template is defined using the template keyword followed by the template parameter list enclosed in angle brackets.
 The template parameter list can include one or more template parameters, 
which can be data types or non-type parameters such as integers or booleans.
 The template parameter list is used to declare one or more template parameters that can be used in the function.

Here is an example of a function template in C++ that can work with different data types:

#include <iostream>

template <typename T>
T max(T a, T b) {
    return a > b ? a : b;
}

int main() {
    int x = 5, y = 10;
    std::cout << "The maximum of " << x << " and " << y << " is " << max(x, y) << std::endl;

    double d1 = 3.14, d2 = 2.71;
    std::cout << "The maximum of " << d1 << " and " << d2 << " is " << max(d1, d2) << std::endl;

    return 0;
}
====================================================================================================
What is a class template in C++?

A class template in C++ is a generic class that can work with different data types.
Class templates allow you to define a single class that can be used with multiple data types,
without having to rewrite the code for each type.

A class template is defined using the template keyword followed by the template parameter list enclosed in angle brackets.
The template parameter list can include one or more template parameters, 
which can be data types or non-type parameters such as integers or booleans. 
The template parameter list is used to declare one or more template parameters that can be used in the class.

Here is an example of a class template in C++ that can work with different data types:

template <typename T>
class Stack {
public:
    void push(T item);
    T pop();
    bool empty() const;
private:
    std::vector<T> data;
};

template <typename T>
void Stack<T>::push(T item) {
    data.push_back(item);
}

template <typename T>
T Stack<T>::pop() {
    T item = data.back();
    data.pop_back();
    return item;
}

template <typename T>
bool Stack<T>::empty() const {
    return data.empty();
}


====================================================================================================
What is a smart pointer in C++?

A smart pointer in C++ is a class that acts as a wrapper around a raw pointer, 
providing automatic memory management and ensuring that memory is properly allocated and deallocated.
Smart pointers are used to avoid common problems associated with
manual memory management such as memory leaks, double deletion of memory, and dangling pointers.

====================================================================================================

What is a reference in C++?
====================================================================================================
What is a const pointer in C++?

In C++, a const pointer is a pointer that points to a constant value and cannot be used to modify the value it points to.

A const pointer can be declared using the const keyword in the pointer declaration, 
which indicates that the pointer itself is constant, i.e., 

its value cannot be changed once it has been initialized.
However, the value it points to can still be modified if the pointer is not pointing to a constant value.

Here is an example of a const pointer declaration:

==========================================================================================================
What is a volatile variable in C++?

In C++, a volatile variable is a variable that is marked as volatile,
which indicates that its value may change at any time, 
even if there is no visible modification in the code. 
This means that the compiler should not optimize any code that accesses the variable, 
as the variable's value may change in unpredictable ways.

The volatile keyword is used to declare a volatile variable. For example:

volatile int count = 0;
============================================================================================================================================

What is a static variable in C++?

==========================================================================================================
What is the difference between const and volatile in C++?
What is a friend class in C++?
What is an abstract class in C++?
==========================================================================================================
What is a pure virtual function in C++?
==========================================================================================================
What is a virtual destructor in C++?

In C++, a virtual destructor is a special type of destructor that is declared as virtual in a base class.
A virtual destructor is used when a class has one or more virtual functions and may be used as a base class for other derived classes.

The purpose of a virtual destructor is to ensure that the destructor of the most 
derived class is called when an object of a derived class is destroyed. 
If a base class destructor is not declared virtual,
the destructor of the derived class may not be called, leading to undefined behavior.


class Base {
public:
    virtual ~Base() {}
};

class Derived : public Base {
public:
    ~Derived() {
        std::cout << "Derived destructor called" << std::endl;
    }
};

int main() {
    Base* ptr = new Derived();
    delete ptr;
    return 0;
}

==========================================================================================================
What is the difference between public, private and protected in C++?

In C++, public, private, and protected are access modifiers used to specify the access level of class members,
such as variables and functions.

public members can be accessed from anywhere in the program, both within and outside the class.

private members can only be accessed from within the class. They are hidden from the outside world, 
and can only be accessed through public functions or friend functions of the class.

protected members are similar to private members, but can also be accessed by derived classes. 
Protected members are hidden from the outside world, but can be accessed by derived classes and their member functions.

==========================================================================================================

What is an inline function in C++?

In C++, an inline function is a function that is expanded by the compiler at the point where it is called, 
instead of performing a function call. 
This means that the code for the function is inserted directly into the calling code, just like a macro.

Here is an example of an inline function:

inline int add(int a, int b) {
    return a + b;
}

In this example, the inline keyword is used to declare the function add() as an inline function.
 When the add() function is called, the compiler will insert the 
code for the function directly into the calling code, instead of generating a function call.

Inline functions can provide performance benefits in certain situations,
 because they avoid the overhead of a function call. However, 
inline functions can also increase the size of the code,
 because the code for the function is duplicated every time it is called.

In general, inline functions are useful for small, frequently called functions
 that perform simple operations, such as mathematical calculations or data manipulation. 
However, they are not always appropriate for larger functions or 
functions with complex control flow, because the duplicated 
code can increase the size of the program and potentially affect performance.

Note that the inline keyword is only a hint to the 
compiler that the function should be expanded inline,
and the compiler is not required to honor the request. 
The compiler may choose to generate a function call instead of 
inline expansion if it determines that inline expansion is not appropriate.
===================================================================================================================

What is a virtual base class in C++?

In C++, a virtual base class is a base class that is declared as virtual in a derived class.
When a base class is declared virtual, it ensures that only one copy of the base class is
shared among all the derived classes that inherit from it, even if multiple paths of inheritance exist.
==========================================================================================================

What is an exception in C++?

In C++, an exception is an error or unexpected event that occurs during the execution of a program and disrupts the normal flow of control. 
Exceptions are used to handle errors and other exceptional conditions that may arise in a program.

When an exception is thrown, the program tries to find a matching exception handler to catch the exception and handle it. 
If no matching handler is found, the program will terminate.

Here's an example to illustrate the use of exceptions in C++:

#include <iostream>

int main() {
    int x, y;
    std::cout << "Enter two numbers: ";
    std::cin >> x >> y;

    try {
        if (y == 0) {
            throw "Division by zero error"; // throw an exception if y is zero
        }
        std::cout << "The result of division is: " << x / y << std::endl; // divide x by y
    }
    catch (const char* message) { // catch the exception and print an error message
        std::cout << "Error: " << message << std::endl;
    }

    return 0;
}

==========================================================================================================
What is the difference between try and catch in C++?


In C++, try and catch are used in exception handling, which is a mechanism for handling errors 
or exceptional conditions that occur during the execution of a program.

try and catch work together to catch and handle exceptions that are thrown by the program. Here's how they work:

try block: The try block contains the code that might throw an exception. 
	   If an exception is thrown, the try block stops executing and control is passed to the nearest matching catch block.

catch block: The catch block is used to handle the exception that was thrown in the try block.
	     It contains code that is executed if the exception matches the type of the catch block.

Here's an example:
try {
    // some code that might throw an exception
}
catch (exception_type e) {
    // handle the exception here
}

In this example, the try block contains code that might throw an exception.
 If an exception is thrown, the catch block is executed, 
and the exception is passed to it as a parameter. 
The type of the exception that the catch block can handle is specified in the parentheses after the catch keyword.

The key difference between try and catch is that try is used to enclose the code that might throw an exception, 
while catch is used to handle the exception that was thrown.
try and catch work together to provide a mechanism for detecting and handling exceptions in a program.

Note that in C++, it's possible to have multiple catch blocks that handle different types of exceptions.
In this case, the first matching catch block is executed,
and the others are skipped. Also, if no matching catch block is found, 
the program terminates with an unhandled exception.

==========================================================================================================
What is the standard template library (STL) in C++?


The Standard Template Library (STL) is a set of C++ template classes and functions that provide
 a collection of commonly used data structures and algorithms. The STL is part of the C++ Standard Library,
 which is a collection of pre-defined classes and functions that can be used in C++ programs.

The STL provides a wide range of container classes, such as vectors, lists, sets, and maps,
 which can be used to store and manipulate data in various ways. It also provides a set of generic algorithms, 
such as sorting, searching, and merging, that can be used with any container class that supports the required operations.

Here are some of the main components of the STL:

Containers: The STL provides a set of container classes that can be used to store and manipulate data. 
These include sequence containers (such as vectors and lists), associative containers (such as sets and maps),
 and container adaptors (such as stacks and queues).

Algorithms: The STL provides a set of generic algorithms that can be used with any container class that supports 7the required operations. 
These include sorting, searching, merging, and more.

Iterators: The STL provides a set of iterator classes that can be used to traverse container elements. 
		These include input iterators, output iterators, forward iterators, bidirectional iterators, and random access iterators.

The STL is widely used in C++ programming, and it provides a powerful set of tools for working with data structures and algorithms. 
Its generic design and use of templates make it flexible and reusable, and its performance is generally very good, 
thanks to its efficient implementation and use of standard algorithms.

==========================================================================================================
What are containers in STL?

In the context of the C++ Standard Template Library (STL), 
a container is a class template that provides a way to store and manipulate a collection of elements. 
Containers are an essential component of the STL, 
and they provide a high-level interface for managing data structures in a C++ program.

There are several types of containers in the STL, each with its own set of features and characteristics. 
Here's a brief overview of some of the most commonly used container classes in the STL:

Sequence containers: These containers maintain a sequence of elements in a linear order, 
			and they provide fast random access to elements. Examples include vectors, lists, and deque.

Associative containers: These containers store elements in a sorted order, 
			and they provide fast lookup and insertion of elements.
			 Examples include sets, multisets, maps, and multimaps.

Container adaptors: These are specialized container classes that provide a specific interface for adapting an existing container to a new use. 
		   Examples include stacks, queues, and priority queues.

Each container class in the STL provides a set of member functions for adding, removing, and accessing elements,
 as well as iterators for iterating over the elements in the container.
 In addition, the STL provides a set of generic algorithms that can be used with any container type,
 allowing for powerful and flexible manipulation of container data.

Overall, containers in the STL provide a high-level interface for managing collections of data in a C++ program, 
and they are an essential tool for any C++ programmer working with data structures.

==========================================================================================================

What is a vector in C++?

In C++, a vector is a container class from the Standard Template Library (STL) 
that provides a dynamic array that can grow and shrink in size at runtime. 
A vector can hold a collection of elements of the same data type, such as integers, strings, or objects.

Here's an example of how to create and use a vector in C++:

#include <vector>
#include <iostream>

int main() {
    std::vector<int> my_vector; // create an empty vector of integers

    my_vector.push_back(1); // add an element to the end of the vector
    my_vector.push_back(2);
    my_vector.push_back(3);

    std::cout << "The size of my_vector is: " << my_vector.size() << std::endl; // output the size of the vector

    for (int i = 0; i < my_vector.size(); i++) {
        std::cout << "Element " << i << " is: " << my_vector[i] << std::endl; // output each element of the vector
    }

    return 0;
}


In this example, we first include the <vector> header to use the vector class.
We then create an empty vector of integers using std::vector<int> my_vector;. 
We can then use the push_back() function to add elements to the end of the vector. We can access the elements of the vector using the subscript operator [], and we can get the size of the vector using the size() function.

Vectors are useful because they provide a flexible and efficient way to store and manipulate collections of elements in a C++ program. They provide fast random access to elements, and they can dynamically grow and shrink in size as needed.
==========================================================================================================
What is a list in C++?

==========================================================================================================

What is a deque in C++?

==========================================================================================================
What is a map in C++?

==========================================================================================================
What is a set in C++?

==========================================================================================================
What is an iterator in C++?

==========================================================================================================

What is a reverse iterator in C++?

==========================================================================================================
What is an algorithm in C++?

==========================================================================================================
What is the difference between an iterator and a pointer in C++?

==========================================================================================================
What is a lambda expression in C++?
What is a functor in C++?
==========================================================================================================
What is a thread in C++?

=====================================================
What is a mutex in C++?

=====================================================
What is a condition variable in C++?
What is a future in C++?
What is a promise in C++?
What is a lambda capture in C++?

==========================================================================================================
What is a move constructor in C++?
What is a move assignment operator in C++?
==========================================================================================================
What is the difference between copy constructor and move constructor in C++?


Copy Constructor:
=================
A copy constructor creates a new object by copying the contents of an existing object.
 It takes an object of the same class as a parameter and creates a new object with the same values. 

class MyClass {
public:
    MyClass(const MyClass& other) {
        // copy constructor code
    }
};

In this example, other is the object that is being copied.


Move Constructor:
A move constructor creates a new object by "moving" the contents of an existing object.
 Instead of copying the contents, the move constructor transfers ownership of the contents to the new object.

class MyClass {
public:
    MyClass(MyClass&& other) noexcept {
        // move constructor code
    }
};


The key difference between copy constructor and move constructor is that copy constructor creates 
a new object by copying the contents of an existing object, 
while move constructor creates a new object by moving the contents of an existing object.

Copy constructor is used when we want to create a new object with the same values as an existing object,
whereas move constructor is used when we want to create 
a new object and transfer ownership of the contents from an existing object to the new object.

======================================================================================


What is the difference between copy assignment operator and move assignment operator in C++?
What is perfect forwarding in C++?
What is a tuple in C++?
What is a variadic template in C++?
What is a pack expansion in C++?
What is a fold expression in C++?
What is a concept in C++?
What is a constraint in C++?
What is a requires expression in C++?
=====================================================